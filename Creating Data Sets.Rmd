---
title: "Creating Data Sets"
author: "Andrew Deighan"
date: "July 6, 2017"
output: html_document
---

  Load necessary libraries
```{r loadlibraries, message=FALSE}
library(httr)
library(jsonlite)
library(dplyr)
library(tidyr)
```

<br>

## Loading Data Via APIs

 For consumption, emissions, and expenditures there are individual data sets for each sector. Thus, multiple API requests must be made for each state.

<br>

### Loading Consumption Data

 For consumption data we are interested in the five primary sectors: residential, commercial, industrial, electric power, and transportation. Additionally, for the residential, commericial, and industrial, sectors we are also specifically interested in consumption data for electricity. Finally, we also want total consumption data across all sectors and total electricity consumption across all sectors. Thus for each state we will make 10 API requests:
 
- State Total
- State Total: Electricity
- Residential
- Residential: Electricity
- Commercial
- Commercial: Electricity
- Industrial
- Industrial: Electricity
- Electric Power
- Transportation

<br>

 

  Create functions for downloading consumption data
```{r consmpFunctions, message=FALSE}
# Function for downloading data files
consumption.download <- function(state, sector) {
     # Function takes two letter upper-case state abbreviation and name of
     # desired sector as arguments and returns consumption data set for that
     # state and sector
     
     require(httr)
     require(jsonlite)
     require(dplyr)
     
     # Select proper sector code
     if(sector == "all") {sc <- ".TETCB."}
     else if(sector == "all: electricity") {sc <- ".ESTCB."}
     else if(sector == "commercial") {sc <- ".TECCB."}
     else if(sector == "commercial: electricity") {sc <- ".ESCCB."}
     else if(sector == "electric power") {sc <- ".TEEIB."}
     else if(sector == "industrial") {sc <- ".TEICB."}
     else if(sector == "industrial: electricity") {sc <- ".ESICB."}
     else if(sector == "residential") {sc <- ".TERCB."}
     else if(sector == "residential: electricity") {sc <- ".ESRCB."}
     else if(sector == "transportation") {sc <- ".TEACB."}
     else {print("Error, incorrect sector name")}

     # Create request key  
     suppressWarnings(ek <- readLines("EIAkey.txt"))
     key <- paste("api_key=", ek, sep = ""); rm(ek)
     uribase <- "http://api.eia.gov/"
  
     meth <- "series/?"
     sabb <- state
     srID <- paste("&series_id=", 
                   "SEDS",
                   sc,
                   sabb,
                   ".A", 
                   sep = "")
  
     call <- paste(uribase,
                   meth,
                   key,
                   srID,
                   sep = "")
  
     # Get raw result to character format 
     raw.result <- GET(url = call)
  
     print(raw.result$status_code)
     
     this.content <- raw.result$content %>%
          rawToChar() %>%
          fromJSON()
     
     #print(str(this.content))
  
     # Convert to data frame
     consumption <- as.data.frame(this.content$series$data) %>%
          rename(year = X1, value = X2) %>%
          mutate(state = sabb,
                 sector = sector,
                 year = as.integer(as.character(year)),
                 measure = "Energy Consumption",
                 unit = "Billions of Btus",
                 value = as.numeric(as.character(value))) %>%
          select(year, state, sector, measure, unit, value) %>%
          filter(year >= 1960) 
  
     return(consumption)
  
     rm(sc, key, uribase,
        meth, sabb, srID,
        call, raw.result, this.content,
        consumption)
}

################################################################################

# Function for compiling individual state
# data (across all sectors)
sector.consumption.getter <- function(state) {
     # Function takes uppercase two-letter state abbreviation and returns data
     # frame with consumption data for all sectors within that state
  
     # Create vector of sectors to loop through
     sectors <- c("all",
                  "all: electricity",
                  "commercial",
                  "commercial: electricity",
                  "electric power",
                  "industrial",
                  "industrial: electricity",
                  "residential",
                  "residential: electricity",
                  "transportation")
  
     # Initiate data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               measure = NULL,
                               unit = NULL,
                               value = NULL)
  
     # Loop through sectors, rowbinding data frames
     for(s in sectors){
          # Call data downloading function
          consumption <- rbind(consumption,
                               consumption.download(state = state, 
                                                    sector = s))
     }
  
     return(consumption)
  
     rm(sectors, consumption, s)
}

################################################################################

# Function for compiling data sets for all states
state.consumption.compiler <- function(states) {
     # Takes a vector of uppercase two-letter state abbreviations and returns a
     # data frame with consumption data for each state in that list.
     
     # Initialize data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               measure = NULL,
                               unit = NULL,
                               value = NULL)
     
     # Loop over list of states
     for(s in states){
          # Call state data compiler function
          consumption <- rbind(consumption,
                               sector.consumption.getter(state = s))
     }
  
     return(consumption)
  
     rm(consumption, s)
}
```

<br>

 Download consumption data
```{r consmpDownload, results="hide", cache=TRUE}
states <- c(state.abb, "DC")

consumption.data <- state.consumption.compiler(states = states)
```


<br>
<br>

### Loading Emissions Data

 For emissions data we are interested in emissions data for each of the five primary sectors as well as state totals, so for each state we will make 6 API requests. 

- State Total
- Residential
- Commercial
- Industrial
- Electric Power
- Transportation

<br>

  Create functions for downloading emissions data
```{r emissFunctions, message=FALSE}
# Function for downloading data files
emission.download <- function(state, sector) {
     # Function takes two letter upper-case state abbreviation and name of
     # desired sector as arguments and returns emission data set for that state 
     # and sector
     
     require(httr)
     require(jsonlite)
     require(dplyr)
  
     if(sector == "all") {sc <- "TT"}
     else if(sector == "commercial") {sc <- "CC"}
     else if(sector == "electric power") {sc <- "EC"}
     else if(sector == "industrial") {sc <- "IC"}
     else if(sector == "residential") {sc <- "RC"}
     else if(sector == "transportation") {sc <- "TC"}

     # Create request key  
     suppressWarnings(ek <- readLines("EIAkey.txt"))
     key <- paste("api_key=", ek, sep = ""); rm(ek)
     uribase <- "http://api.eia.gov/"
  
     meth <- "series/?"
     sabb <- state
     srID <- paste("&series_id=", 
                   "EMISS.CO2-TOTV-",
                   sc,
                   "-TO-",
                   sabb,
                   ".A", 
                   sep = "")
  
     call <- paste(uribase,
                   meth,
                   key,
                   srID,
                   sep = "")
  
     # Get raw result to character format 
     raw.result <- GET(url = call)
  
     print(raw.result$status_code)
  
     this.content <- raw.result$content %>%
          rawToChar() %>%
          fromJSON()
     
     #print(str(this.content))
     
     # Convert to data frame
     consumption <- as.data.frame(this.content$series$data) %>%
          rename(year = X1, value = X2) %>%
          mutate(state = sabb,
                 sector = sector,
                 year = as.integer(as.character(year)),
                 measure = "CO2 Emissions",
                 unit = "Millions of Metric Tons",
                 value = as.numeric(as.character(value))) %>%
          select(year, state, sector, measure, unit, value) %>%
          filter(year >= 1960) 
  
     return(consumption)
  
     rm(sc, key, uribase,
        meth, sabb, srID,
        call, raw.result, this.content,
        consumption)
}

################################################################################

# Function for compiling individual state
# data (across all sectors)
sector.emission.getter <- function(state) {
     # Function takes uppercase two-letter state abbreviation and returns data
     # frame with emission data for all sectors within that state
  
     # Create vector of sectors to loop through
     sectors <- c("all",
                  "commercial",
                  "electric power",
                  "industrial",
                  "residential",
                  "transportation")
  
     # Initiate data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               measure = NULL,
                               unit = NULL,
                               value = NULL)
  
     # Loop through sectors, rowbinding data frames
     for(s in sectors){
          # Call data downloading function
          consumption <- rbind(consumption,
                               emission.download(state = state, sector = s))
     }
  
     return(consumption)
  
     rm(sectors, consumption, s)
}

################################################################################

# Function for compiling data sets for all states
state.emission.compiler <- function(states) {
     # Takes a vector of uppercase two-letter state abbreviations and returns a
     # data frame with emission data for each state in that list.
     
     # Initialize data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               measure = NULL,
                               unit = NULL,
                               value = NULL)
     
     # Loop over list of states
     for(s in states){
          # Call state data compiler function
          consumption <- rbind(consumption,
                               sector.emission.getter(state = s))
     }
  
     return(consumption)
  
     rm(consumption, s)
}
```

<br>

 Download emissions data
```{r emissDownload, results="hide", cache=TRUE}
states <- c(state.abb, "DC")

emissions.data <- state.emission.compiler(states = states)
```

<br>

<br>
<br>

### Loading Expenditures (price) Data
 For expenditures, as with consumption, we are interested in the totals for all five primary sectors as well as the electricity expenditures for the residential sector, commercial sector, industrial sector, and state total. Thus for each state we will make 10 API requests.
 
- State Total
- State Total: Electricity
- Residential
- Residential: Electricity
- Commercial
- Commercial: Electricity
- Industrial
- Industrial: Electricity
- Electric Power
- Transportation

<br>

 Create functions for downloading expenditures data
```{r expendFunctions, message=FALSE}
# Function for downloading data files
expenditures.download <- function(state, sector) {
     # Function takes two letter upper-case state abbreviation and name of
     # desired sector as arguments and returns expenditure data set for that
     # state and sector
     
     require(httr)
     require(jsonlite)
     require(dplyr)
     
     # Select proper sector code
     if(sector == "all") {sc <- ".TETCV."}
     else if(sector == "all: electricity") {sc <- ".ESTCV."}
     else if(sector == "commercial") {sc <- ".TECCV."}
     else if(sector == "commercial: electricity") {sc <- ".ESCCV."}
     #else if(sector == "electric power") {sc <- ".TEEIB."}
     else if(sector == "industrial") {sc <- ".TEICV."}
     else if(sector == "industrial: electricity") {sc <- ".ESICV."}
     else if(sector == "residential") {sc <- ".TERCV."}
     else if(sector == "residential: electricity") {sc <- ".ESRCV."}
     else if(sector == "transportation") {sc <- ".TEACV."}
     else {print("Error, incorrect sector name"); print(sector)}

     # Create request key  
     suppressWarnings(ek <- readLines("EIAkey.txt"))
     key <- paste("api_key=", ek, sep = ""); rm(ek)
     uribase <- "http://api.eia.gov/"
  
     meth <- "series/?"
     sabb <- state
     srID <- paste("&series_id=", 
                   "SEDS",
                   sc,
                   sabb,
                   ".A", 
                   sep = "")
  
     call <- paste(uribase,
                   meth,
                   key,
                   srID,
                   sep = "")
  
     # Get raw result to character format 
     raw.result <- GET(url = call)
  
     print(raw.result$status_code)
     
     this.content <- raw.result$content %>%
          rawToChar() %>%
          fromJSON()
     
     #print(str(this.content))
  
     # Convert to data frame
     consumption <- as.data.frame(this.content$series$data) %>%
          rename(year = X1, value = X2) %>%
          mutate(state = sabb,
                 sector = sector,
                 year = as.integer(as.character(year)),
                 measure = "Energy Expenditures",
                 unit = "Millions of Dollars",
                 value = as.numeric(as.character(value))) %>%
          select(year, state, sector, measure, unit, value) %>%
          filter(year >= 1960) 
  
     return(consumption)
  
     rm(sc, key, uribase,
        meth, sabb, srID,
        call, raw.result, this.content,
        consumption)
}

################################################################################

# Function for compiling individual state
# data (across all sectors)
sector.expenditures.getter <- function(state) {
     # Function takes uppercase two-letter state abbreviation and returns data
     # frame with expenditure data for all sectors within that state
  
     # Create vector of sectors to loop through
     sectors <- c("all",
                  "all: electricity",
                  "commercial",
                  "commercial: electricity",
                  #"electric power",
                  "industrial",
                  "industrial: electricity",
                  "residential",
                  "residential: electricity",
                  "transportation")
  
     # Initiate data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               measure = NULL,
                               unit = NULL,
                               value = NULL)
  
     # Loop through sectors, rowbinding data frames
     for(s in sectors){
          # Call data downloading function
          consumption <- rbind(consumption,
                               expenditures.download(state = state, 
                                                    sector = s))
     }
  
     return(consumption)
  
     rm(sectors, consumption, s)
}

################################################################################

# Function for compiling data sets for all states
state.expenditures.compiler <- function(states) {
     # Takes a vector of uppercase two-letter state abbreviations and returns a
     # data frame with expenditure data for each state in that list.
     
     # Initialize data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               measure = NULL,
                               unit = NULL,
                               value = NULL)
     
     # Loop over list of states
     for(s in states){
          # Call state data compiler function
          consumption <- rbind(consumption,
                               sector.expenditures.getter(state = s))
     }
  
     return(consumption)
  
     rm(consumption, s)
}
```

<br>

 Download expenditures data
```{r expendDownload, results="hide", cache=TRUE}
states <- c(state.abb, "DC")

expenditures.data <- state.expenditures.compiler(states = states)
```

<br>
<br>

### Loading Energy Production Data

 For energy production data we are interested in total state energy production and total state renewable energy (excluding ethanol) production. Thus for each state we will be making two API requests:

- Total Energy Production
- Renewable (excluding ethanol) Energy Production

<br>

  Create functions for downloading consumption data
```{r prodFunctions, message=FALSE}
# Function for downloading data files
production.download <- function(state, segment) {
     # Function takes two letter upper-case state abbreviation and name of
     # desired segment ('total production' or 'renewable') as arguments and
     # returns production data set for that state and segment
     
     require(httr)
     require(jsonlite)
     require(dplyr)
     
     # Select proper segment code
     if(segment == 'total production') {
          sc <- ".TEPRB."
          meas <- "Total Energy Production"
     }
     else if(segment == "renewable") {
          sc <- ".ROPRB."
          meas <- "Renewable Energy Production"
     }
     
     # Create request key  
     suppressWarnings(ek <- readLines("EIAkey.txt"))
     key <- paste("api_key=", ek, sep = ""); rm(ek)
     uribase <- "http://api.eia.gov/"
  
     meth <- "series/?"
     sabb <- state
     srID <- paste("&series_id=", 
                   "SEDS",
                   sc,
                   sabb,
                   ".A", 
                   sep = "")
  
     call <- paste(uribase,
                   meth,
                   key,
                   srID,
                   sep = "")
  
     # Get raw result to character format 
     raw.result <- GET(url = call)
  
     print(raw.result$status_code)
     
     this.content <- raw.result$content %>%
          rawToChar() %>%
          fromJSON()
     
     #print(str(this.content))
  
     # Convert to data frame
     consumption <- as.data.frame(this.content$series$data) %>%
          rename(year = X1, value = X2) %>%
          mutate(state = sabb,
                 sector = NA,
                 year = as.integer(as.character(year)),
                 measure = meas,
                 unit = "Billions of Btus",
                 value = as.numeric(as.character(value))) %>%
          select(year, state, sector, measure, unit, value) %>%
          filter(year >= 1960) 
  
     return(consumption)
  
     rm(sc, key, uribase,
        meth, sabb, srID,
        call, raw.result, this.content,
        consumption)
}

################################################################################

# Function for compiling individual state data
segment.production.getter <- function(state) {
     # Function takes uppercase two-letter state abbreviation and returns data
     # frame with both total and renewable only energy production within that
     # state
  
     # Create vector of segments to loop through
     sectors <- c("total production",
                  "renewable")
  
     # Initiate data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               measure = NULL,
                               unit = NULL,
                               value = NULL)
  
     # Loop through segments, rowbinding data frames
     for(s in sectors){
          # Call data downloading function
          consumption <- rbind(consumption,
                               production.download(state = state, 
                                                   segment = s))
     }
  
     return(consumption)
  
     rm(sectors, consumption, s)
}

################################################################################

# Function for compiling data sets for all states
state.production.compiler <- function(states) {
     # Takes a vector of uppercase two-letter state abbreviations and returns a
     # data frame with energy production data for each state in that list.
     
     # Initialize data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               measure = NULL,
                               unit = NULL,
                               value = NULL)
     
     # Loop over list of states
     for(s in states){
          # Call state data compiler function
          consumption <- rbind(consumption,
                               segment.production.getter(state = s))
     }
  
     return(consumption)
  
     rm(consumption, s)
}
```

<br>

 Download production data
```{r prodDownload, results="hide", cache=TRUE}
states <- c(state.abb, "DC")

production.data <- state.production.compiler(states = states)
```

<br>
<br>

### Loading Population Data
 
 In addition to information on energy use, production, cost, and emissions we also want more demographic/economic data on state population and gross domestic product (GDP). State population figures we can request directly from the EIA via their API. The EIA also has GDP data for states, but not as far back as th 1960s, so we will have to go elsewhere to get this information (explained in next [section](#loading-gdp-data)). For population data we only need to make one API request per state:

- Total State Population

<br>

 Create functions for retrieving population data:

```{r popFunctions, message=FALSE}
# Function for downloading data files
population.download <- function(state) {
     # Function takes two letter upper-case state abbreviation as an argument 
     # and returns population data set for that state.
     
     require(httr)
     require(jsonlite)
     require(dplyr)
     
     # Create request key  
     suppressWarnings(ek <- readLines("EIAkey.txt"))
     key <- paste("api_key=", ek, sep = ""); rm(ek)
     uribase <- "http://api.eia.gov/"
  
     meth <- "series/?"
     sabb <- state
     srID <- paste("&series_id=SEDS.TPOPP.",
                   sabb,
                   ".A", 
                   sep = "")
  
     call <- paste(uribase,
                   meth,
                   key,
                   srID,
                   sep = "")
  
     # Get raw result to character format 
     raw.result <- GET(url = call)
  
     print(raw.result$status_code)
     
     this.content <- raw.result$content %>%
          rawToChar() %>%
          fromJSON()
     
     #print(str(this.content))
  
     # Convert to data frame
     consumption <- as.data.frame(this.content$series$data) %>%
          rename(year = X1, value = X2) %>%
          mutate(state = sabb,
                 sector = NA,
                 year = as.integer(as.character(year)),
                 measure = "Population",
                 unit = "Thousands of Persons",
                 value = as.numeric(as.character(value))) %>%
          select(year, state, sector, measure, unit, value) %>%
          filter(year >= 1960) 
  
     return(consumption)
  
     rm(sc, key, uribase,
        meth, sabb, srID,
        call, raw.result, this.content,
        consumption)
}

################################################################################

# Function for compiling data sets for all states
state.population.compiler <- function(states) {
     # Takes a vector of uppercase two-letter state abbreviations and returns a
     # data frame with population data for each state in that list.
     
     # Initialize data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               measure = NULL,
                               unit = NULL,
                               value = NULL)
     
     # Loop over list of states
     for(s in states){
          # Call state data compiler function
          consumption <- rbind(consumption,
                               population.download(state = s))
     }
  
     return(consumption)
  
     rm(consumption, s)
}
```

<br>

 Download population data
```{r popDownload, results="hide", cache=TRUE}
states <- c(state.abb, "DC")

population.data <- state.population.compiler(states = states)
```

<br>
<br>

### Loading GDP Data

 The GDP data were aquired from the Bureau of Economic Analysis (BEA). Before 1997 BEA used the Standard Industrial Classification (SIC) system for classifying industries when calculating GDP. In 1997, BEA switched to using the North American Industry Classification System (NAICS). For 1997 BEA reports GDP estimates calculate using both the NAICS and SIC system. The fact the the 1997 estimates differ slightly between these two systems should be kept in mind when are comparing pre and post 1997 GDP data. That being said, we will use GDP estimates calculated using the SIC system for years before 1997 and NAICS for years from 1997 onwards. We will use current dollar GDP values rather than GDP values adjusted for inflation. Since our planned analysis primarily involves Maine's *relative* performance to the rest of the country, adjusting GDP values for inflation would have no effect (since the conversion factor would cancel out).
 
<br>

 Create functions for fetching GDP data
```{r gdpFunctions}
gdp.download <- function(component, years, states = NULL){
     # Function takes two arguments, component name (string) and a vector of
     # years (integer). The function returns a data frame with total industry
     # GDP data for those years, for all states.
     
     require(httr)
     require(jsonlite)
     require(dplyr)
     
     # Load user API key from text file
     suppressWarnings(bk <- readLines("beakey.txt"))
     key <- paste("?&UserID=", bk, sep = "")
     # Specify base uri
     uri <- "https://www.bea.gov/api/data"
  
     # Choose the "get data" method which is for requesting data
     meth <- "GetData"
     # Choose the data set, the regional product data set includes GDP data
     # for all states, the country as a whole, and several regions of the
     # country (we will remove the regional data)
     ds <- "RegionalProduct"
     # Specify which GDP compenent we're interested in (NAICS or SIC)
     comp <- component
     # Request GDP data for all states unless specific states are specified
     if(is.null(states)) {area <- "STATE"}
     else {area <- paste(states, collapse = ",")}
     # The industry code "1" indicates that we want the total GDP data for
     # all industries
     inds <- 1
     # Request GDP data for designated years
     year <- paste(years, collapse = ",")
     
     # Construct API call
     call <- paste(uri, 
                   key,
                   "&method=", meth,
                   "&datasetname=", ds,
                   "&Component=", comp,
                   "&GeoFips=", area,
                   "&IndustryId=", inds,
                   "&Year=", year,
                   sep = "")
     
     content <- GET(url = call)$content %>%
     rawToChar() %>%
     fromJSON()
     
     if(length(names(content$BEAAPI$Results)) == 1){
          if(names(content$BEAAPI$Results) == 1){
               stop("Error in API request, likely invalid component name")
          }
          else{
               print("may be some error... check code and output carefully")
          }
     }
     
     if(component == "GDP_SAS"){units <- "SIC GDP: Millions of Current Dollars"}
     else if(component == "GDP_SAN"){units <- "NAICS GDP: Millions of Current Dollars"}
     else{units <- component}
     
     
     tidyGDP <- content$BEAAPI$Results$Data %>%
          select(TimePeriod, GeoName, Code, DataValue) %>%
          rename(year = TimePeriod,
                 state = GeoName,
                 unit = Code,
                 value = DataValue) %>%
          mutate(year = as.integer(year),
                 measure = "Gross Domestic Product",
                 unit = units,
                 value = as.integer(value),
                 sector = NA) %>%
          select(year, state, sector, measure, unit, value)
     
     states <- c(state.name, "District of Columbia", "United States")
     
     tidyGDP <- tidyGDP %>%
          filter(state %in% states) %>%
          arrange(year, state, sector)
     
     return(tidyGDP)
}

gdp.sic.naics <- function(s = NULL){
     gdp.data <- gdp.download(component = "GDP_SAS", 
                              years = 1960:1996,
                              states = s)
     gdp.data <- rbind(gdp.data,
                  gdp.download(component = "GDP_SAN", 
                               years = 1997:2015,
                               states = s))
     return(gdp.data)
}
```

<br>

 Get SIC and NAICS GDP data and combine the data sets together
```{r getGDP, results="hide", , cache=TRUE}
gdp.data <- gdp.sic.naics()
```


<br>
<br>

## Merging Data Sets and Calculating Absolute and Relative Performance Measures

 We now have six data sets with:

- Consumption Data
- Emissions Data
- Expenditures Data
- Energy Production Data
- Population Data
- GDP Data

 We want to merge these six data sets into one and calculate for each state three measures:
 
- Conversion Efficiency: Current dollars GDP per millions of consumed Btu
- Production Efficiency: Consumed Btu per current dollars spent on energy
- Externality Efficiency: Millions of consumed Btu per metric ton of CO2 emitted
- Production to Consumption: Produced Btu per consumed Btu
- Fraction Renewable: Renewably produced Btu per total produced Btu

 What we are primarily interested in is Maine's *relative* performance compared to other states, regions, divisions, and the country as a whole. Thus, in addition to calculating the above metrics for each state, we will also want to calculate them for each region, division, and the entire country so that we can then get relative measures to compare Maine to. In order to accomplish this we will add the columns "region" and "division" to the energy consumption data set before merging the data sets together.

<br>

 Adding **region** and **division** columns to consumption data set: 
```{r addDivReg, results="hide", cache=TRUE}
# Create function for changing state abbreviations to full names
name.changer <- function(abb){
     
     statenames <- c(tolower(state.name), "district of columbia")
     stateabbs <- c(state.abb, "DC")
     
     name <- statenames[stateabbs == abb]
     return(name)
}

# Create function for determining division
find.div <- function(state){
     
     divnames <- c(tolower(as.character(state.division)), 
                   "south atlantic")
     statenames <- c(tolower(state.name), 
                     "district of columbia")
     
     division <- divnames[statenames == state]
     return(division)
}

# Create function for determining region
find.reg <- function(div){
     
     regnames <- c(tolower(as.character(state.region)), 
                   "south")
     divnames <- c(tolower(state.division), 
                     "south atlantic")
     
     region <- unique(regnames[divnames == div])
     return(region)
}


# Update consumption data set

consumption.data <- consumption.data %>%
     mutate(state = as.character(lapply(state, name.changer)),
            division = as.character(lapply(state, find.div)),
            region = as.character(lapply(division, find.reg))) %>%
     select(year, state, region, division, sector, measure, unit, value)

```

<br>

 Now that we have added region and division values to the consumption data set we will merge all the data sets together:
```{r mergeDatasets, results="hide", cache=TRUE}
# First we will make sure all the data sets have full state names for the
# "state" variable before merging
name.changer2 <- function(dataset){
     require(dplyr)
     
     dataset <- dataset %>%
          mutate(state = as.character(lapply(state, name.changer)))
     
     return(dataset)
}

emissions.data <- name.changer2(emissions.data)
expenditures.data <- name.changer2(expenditures.data)
production.data <- name.changer2(production.data)
population.data <- name.changer2(population.data)

# Now we will merge the data sets
merged <- consumption.data %>% 
     merge(emissions.data,
           by("year", "state", "sector"), all.x = TRUE) %>%
     merge(expenditures.data,
           by("year", "state", "sector"), all.x = TRUE) %>%
     merge(production.data,
           by("year", "state"), all.x = TRUE) %>%
     merge(population.data,
           by("year", "state"), all.x = TRUE) %>%
     merge(gdp.data,
           by("year", "state"), all.x = TRUE)


```
 



























