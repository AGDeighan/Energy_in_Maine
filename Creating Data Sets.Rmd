---
title: "Creating Data Sets"
author: "Andrew Deighan"
date: "July 6, 2017"
output: html_document
---

  Load necessary libraries
```{r loadlibraries, message=FALSE}
library(httr)
library(jsonlite)
library(dplyr)
library(tidyr)
```

<br>

## Loading Data Via APIs

 For consumption, emissions, and expenditures there are individual data sets for each sector. Thus, multiple API requests must be made for each state.

<br>

### Loading Consumption Data

 For consumption data we are interested in the five primary sectors: residential, commercial, industrial, electric power, and transportation. Additionally, for the residential, commericial, and industrial, sectors we are also specifically interested in consumption data for electricity. Finally, we also want total consumption data across all sectors and total electricity consumption across all sectors. Thus for each state we will make 10 API requests:
 
- State Total
- State Total: Electricity
- Residential
- Residential: Electricity
- Commercial
- Commercial: Electricity
- Industrial
- Industrial: Electricity
- Electric Power
- Transportation

<br>

 

  Create functions for downloading consumption data
```{r consmpFunctions, message=FALSE}
# Function for downloading data files
consumption.download <- function(state, sector) {
     # Function takes two letter upper-case state abbreviation and name of
     # desired sector as arguments and returns consumption data set for that
     # state and sector
     
     require(httr)
     require(jsonlite)
     require(dplyr)
     
     # Select proper sector code
     if(sector == "all") {sc <- ".TETCB."}
     else if(sector == "all: electricity") {sc <- ".ESTCB."}
     else if(sector == "commercial") {sc <- ".TECCB."}
     else if(sector == "commercial: electricity") {sc <- ".ESCCB."}
     else if(sector == "electric power") {sc <- ".TEEIB."}
     else if(sector == "industrial") {sc <- ".TEICB."}
     else if(sector == "industrial: electricity") {sc <- ".ESICB."}
     else if(sector == "residential") {sc <- ".TERCB."}
     else if(sector == "residential: electricity") {sc <- ".ESRCB."}
     else if(sector == "transportation") {sc <- ".TEACB."}
     else {print("Error, incorrect sector name")}

     # Create request key  
     suppressWarnings(ek <- readLines("EIAkey.txt"))
     key <- paste("api_key=", ek, sep = ""); rm(ek)
     uribase <- "http://api.eia.gov/"
  
     meth <- "series/?"
     sabb <- state
     srID <- paste("&series_id=", 
                   "SEDS",
                   sc,
                   sabb,
                   ".A", 
                   sep = "")
  
     call <- paste(uribase,
                   meth,
                   key,
                   srID,
                   sep = "")
  
     # Get raw result to character format 
     raw.result <- GET(url = call)
  
     print(raw.result$status_code)
     
     this.content <- raw.result$content %>%
          rawToChar() %>%
          fromJSON()
     
     #print(str(this.content))
  
     # Convert to data frame
     consumption <- as.data.frame(this.content$series$data) %>%
          rename(year = X1, value = X2) %>%
          mutate(state = sabb,
                 sector = sector,
                 year = as.integer(as.character(year)),
                 unit = "Billions of Btu Consumed",
                 value = as.numeric(as.character(value))) %>%
          select(year, state, sector, unit, value) %>%
          filter(year >= 1960) 
  
     return(consumption)
  
     rm(sc, key, uribase,
        meth, sabb, srID,
        call, raw.result, this.content,
        consumption)
}

################################################################################

# Function for compiling individual state
# data (across all sectors)
sector.consumption.getter <- function(state) {
     # Function takes uppercase two-letter state abbreviation and returns data
     # frame with consumption data for all sectors within that state
  
     # Create vector of sectors to loop through
     sectors <- c("all",
                  "all: electricity",
                  "commercial",
                  "commercial: electricity",
                  "electric power",
                  "industrial",
                  "industrial: electricity",
                  "residential",
                  "residential: electricity",
                  "transportation")
  
     # Initiate data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               unit = NULL,
                               value = NULL)
  
     # Loop through sectors, rowbinding data frames
     for(s in sectors){
          # Call data downloading function
          consumption <- rbind(consumption,
                               consumption.download(state = state, 
                                                    sector = s))
     }
  
     return(consumption)
  
     rm(sectors, consumption, s)
}

################################################################################

# Function for compiling data sets for all states
state.consumption.compiler <- function(states) {
     # Takes a vector of uppercase two-letter state abbreviations and returns a
     # data frame with consumption data for each state in that list.
     
     # Initialize data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               unit = NULL,
                               value = NULL)
     
     # Loop over list of states
     for(s in states){
          # Call state data compiler function
          consumption <- rbind(consumption,
                               sector.consumption.getter(state = s))
     }
  
     return(consumption)
  
     rm(consumption, s)
}
```

<br>

 Download consumption data
```{r consmpDownload, results="hide"}
states <- c(state.abb, "DC")

consumption.data <- state.consumption.compiler(states = states)
```

<br>

<br>

### Loading Emissions Data

 For emissions data we are interested in emissions data for each of the five primary sectors as well as state totals, so for each state we will make 6 API requests. 

- State Total
- Residential
- Commercial
- Industrial
- Electric Power
- Transportation

<br>

  Create functions for downloading emissions data
```{r emissFunctions, message=FALSE}
# Function for downloading data files
emission.download <- function(state, sector) {
     # Function takes two letter upper-case state abbreviation and name of
     # desired sector as arguments and returns emission data set for that state 
     # and sector
     
     require(httr)
     require(jsonlite)
     require(dplyr)
  
     if(sector == "all") {sc <- "TT"}
     else if(sector == "commercial") {sc <- "CC"}
     else if(sector == "electric power") {sc <- "EC"}
     else if(sector == "industrial") {sc <- "IC"}
     else if(sector == "residential") {sc <- "RC"}
     else if(sector == "transportation") {sc <- "TC"}

     # Create request key  
     suppressWarnings(ek <- readLines("EIAkey.txt"))
     key <- paste("api_key=", ek, sep = ""); rm(ek)
     uribase <- "http://api.eia.gov/"
  
     meth <- "series/?"
     sabb <- state
     srID <- paste("&series_id=", 
                   "EMISS.CO2-TOTV-",
                   sc,
                   "-TO-",
                   sabb,
                   ".A", 
                   sep = "")
  
     call <- paste(uribase,
                   meth,
                   key,
                   srID,
                   sep = "")
  
     # Get raw result to character format 
     raw.result <- GET(url = call)
  
     print(raw.result$status_code)
  
     this.content <- raw.result$content %>%
          rawToChar() %>%
          fromJSON()
     
     #print(str(this.content))
     
     # Convert to data frame
     consumption <- as.data.frame(this.content$series$data) %>%
          rename(year = X1, value = X2) %>%
          mutate(state = sabb,
                 sector = sector,
                 year = as.integer(as.character(year)),
                 unit = "Millions of Metric Tons of CO2 Emitted",
                 value = as.numeric(as.character(value))) %>%
          select(year, state, sector, unit, value) %>%
          filter(year >= 1960) 
  
     return(consumption)
  
     rm(sc, key, uribase,
        meth, sabb, srID,
        call, raw.result, this.content,
        consumption)
}

################################################################################

# Function for compiling individual state
# data (across all sectors)
sector.emission.getter <- function(state) {
     # Function takes uppercase two-letter state abbreviation and returns data
     # frame with emission data for all sectors within that state
  
     # Create vector of sectors to loop through
     sectors <- c("all",
                  "commercial",
                  "electric power",
                  "industrial",
                  "residential",
                  "transportation")
  
     # Initiate data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               unit = NULL,
                               value = NULL)
  
     # Loop through sectors, rowbinding data frames
     for(s in sectors){
          # Call data downloading function
          consumption <- rbind(consumption,
                               emission.download(state = state, sector = s))
     }
  
     return(consumption)
  
     rm(sectors, consumption, s)
}

################################################################################

# Function for compiling data sets for all states
state.emission.compiler <- function(states) {
     # Takes a vector of uppercase two-letter state abbreviations and returns a
     # data frame with emission data for each state in that list.
     
     # Initialize data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               unit = NULL,
                               value = NULL)
     
     # Loop over list of states
     for(s in states){
          # Call state data compiler function
          consumption <- rbind(consumption,
                               sector.emission.getter(state = s))
     }
  
     return(consumption)
  
     rm(consumption, s)
}
```

<br>

 Download emissions data
```{r emissDownload}
states <- c(state.abb, "DC")

emission.data <- state.emission.compiler(states = states)
```

<br>

<br>
<br>

### Loading Expenditures (price) Data
 For expenditures, as with consumption, we are interested in the totals for all five primary sectors as well as the electricity expenditures for the residential sector, commercial sector, industrial sector, and state total. Thus for each state we will make 10 API requests.
 
- State Total
- State Total: Electricity
- Residential
- Residential: Electricity
- Commercial
- Commercial: Electricity
- Industrial
- Industrial: Electricity
- Electric Power
- Transportation

<br>

 Create functions for downloading expenditures data
```{r expendFunctions, message=FALSE}
# Function for downloading data files
expenditures.download <- function(state, sector) {
     # Function takes two letter upper-case state abbreviation and name of
     # desired sector as arguments and returns expenditure data set for that
     # state and sector
     
     require(httr)
     require(jsonlite)
     require(dplyr)
     
     # Select proper sector code
     if(sector == "all") {sc <- ".TETCV."}
     else if(sector == "all: electricity") {sc <- ".ESTCV."}
     else if(sector == "commercial") {sc <- ".TECCV."}
     else if(sector == "commercial: electricity") {sc <- ".ESCCV."}
     #else if(sector == "electric power") {sc <- ".TEEIB."}
     else if(sector == "industrial") {sc <- ".TEICV."}
     else if(sector == "industrial: electricity") {sc <- ".ESICV."}
     else if(sector == "residential") {sc <- ".TERCV."}
     else if(sector == "residential: electricity") {sc <- ".ESRCV."}
     else if(sector == "transportation") {sc <- ".TEACV."}
     else {print("Error, incorrect sector name"); print(sector)}

     # Create request key  
     suppressWarnings(ek <- readLines("EIAkey.txt"))
     key <- paste("api_key=", ek, sep = ""); rm(ek)
     uribase <- "http://api.eia.gov/"
  
     meth <- "series/?"
     sabb <- state
     srID <- paste("&series_id=", 
                   "SEDS",
                   sc,
                   sabb,
                   ".A", 
                   sep = "")
  
     call <- paste(uribase,
                   meth,
                   key,
                   srID,
                   sep = "")
  
     # Get raw result to character format 
     raw.result <- GET(url = call)
  
     print(raw.result$status_code)
     
     this.content <- raw.result$content %>%
          rawToChar() %>%
          fromJSON()
     
     print(str(this.content))
  
     # Convert to data frame
     consumption <- as.data.frame(this.content$series$data) %>%
          rename(year = X1, value = X2) %>%
          mutate(state = sabb,
                 sector = sector,
                 year = as.integer(as.character(year)),
                 unit = "Millions of Dollars Spent",
                 value = as.numeric(as.character(value))) %>%
          select(year, state, sector, unit, value) %>%
          filter(year >= 1960) 
  
     return(consumption)
  
     rm(sc, key, uribase,
        meth, sabb, srID,
        call, raw.result, this.content,
        consumption)
}

################################################################################

# Function for compiling individual state
# data (across all sectors)
sector.expenditures.getter <- function(state) {
     # Function takes uppercase two-letter state abbreviation and returns data
     # frame with expenditure data for all sectors within that state
  
     # Create vector of sectors to loop through
     sectors <- c("all",
                  "all: electricity",
                  "commercial",
                  "commercial: electricity",
                  #"electric power",
                  "industrial",
                  "industrial: electricity",
                  "residential",
                  "residential: electricity",
                  "transportation")
  
     # Initiate data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               unit = NULL,
                               value = NULL)
  
     # Loop through sectors, rowbinding data frames
     for(s in sectors){
          # Call data downloading function
          consumption <- rbind(consumption,
                               expenditures.download(state = state, 
                                                    sector = s))
     }
  
     return(consumption)
  
     rm(sectors, consumption, s)
}

################################################################################

# Function for compiling data sets for all states
state.expenditures.compiler <- function(states) {
     # Takes a vector of uppercase two-letter state abbreviations and returns a
     # data frame with expenditure data for each state in that list.
     
     # Initialize data frame
     consumption <- data.frame(year = NULL,
                               state = NULL, 
                               sector = NULL,
                               unit = NULL,
                               value = NULL)
     
     # Loop over list of states
     for(s in states){
          # Call state data compiler function
          consumption <- rbind(consumption,
                               sector.expenditures.getter(state = s))
     }
  
     return(consumption)
  
     rm(consumption, s)
}
```

<br>

 Download expenditures data
```{r expendDownload}
states <- c(state.abb, "DC")

expenditure.data <- state.expenditures.compiler(states = states)
```

<br>

### Loading GDP Data

 The GDP data were aquired from the Bureau of Economic Analysis (BEA). Before 1997 BEA used the Standard Industrial Classification (SIC) system for classifying industries when calculating GDP. In 1997, BEA switched to using the North American Industry Classification System (NAICS). For 1997 BEA reports GDP estimates calculate using both the NAICS and SIC system. The fact the the 1997 estimates differ slightly between these two systems should be kept in mind when are comparing pre and post 1997 GDP data. That being said, we will use GDP estimates calculated using the SIC system for years before 1997 and NAICS for years from 1997 onwards. We will use current dollar GDP values rather than GDP values adjusted for inflation. Since our planned analysis primarily involves Maine's *relative* performance to the rest of the country, adjusting GDP values for inflation would have no effect (since the conversion factor would cancel out).
 
<br>

 Create functions for fetching GDP data
```{r gdpFunctions}
gdp.download <- function(component, years){
     # Function takes two arguments, component name (string) and a vector of
     # years (integer). The function returns a data frame with total industry
     # GDP data for those years, for all states.
     
     require(httr)
     require(jsonlite)
     require(dplyr)
     
     # Load user API key from text file
     suppressWarnings(bk <- readLines("beakey.txt"))
     key <- paste("?&UserID=", bk, sep = "")
     # Specify base uri
     uri <- "https://www.bea.gov/api/data"
  
     # Choose the "get data" method which is for requesting data
     meth <- "GetData"
     # Choose the data set, the regional product data set includes GDP data
     # for all states, the country as a whole, and several regions of the
     # country (we will remove the regional data)
     ds <- "RegionalProduct"
     # Specify which GDP compenent we're interested in (NAICS or SIC)
     comp <- component
     # Request GDP data for all states
     area <- "STATE"
     # The industry code "1" indicates that we want the total GDP data for
     # all industries
     inds <- 1
     # Request GDP data for designated years
     year <- paste(years, collapse = ",")
     
     # Construct API call
     call <- paste(uri, 
                   key,
                   "&method=", meth,
                   "&datasetname=", ds,
                   "&Component=", comp,
                   "&GeoFips=", area,
                   "&IndustryId=", inds,
                   "&Year=", year,
                   sep = "")
     
     content <- GET(url = call)$content %>%
     rawToChar() %>%
     fromJSON()
     
     if(length(names(content$BEAAPI$Results)) == 1){
          if(names(content$BEAAPI$Results) == 1){
               stop("Error in API request, likely invalid component name")
          }
          else{
               print("may be some error... check code and output carefully")
          }
     }
     
     if(component == "GDP_SAS"){units <- "SIC GDP: Millions of Current Dollars"}
     else if(component == "GDP_SAN"){units <- "NAICS GDP: Millions of Current Dollars"}
     else{units <- component}
     
     
     tidyGDP <- content$BEAAPI$Results$Data %>%
          select(TimePeriod, GeoName, Code, DataValue) %>%
          rename(year = TimePeriod,
                 state = GeoName,
                 unit = Code,
                 value = DataValue) %>%
          mutate(year = as.integer(year),
                 unit = units,
                 value = as.integer(value),
                 sector = NA) %>%
          select(year, state, sector, unit, value)
     
     states <- c(state.name, "District of Columbia", "United States")
     
     tidyGDP <- tidyGDP %>%
          filter(state %in% states) %>%
          arrange(year, state, sector)
     
     return(tidyGDP)
}
```

<br>

 Get SIC and NAICS GDP data and combine the data sets together
```{r getGDP}
gdp.data <- gdp.download(component = "GDP_SAS", years = 1960:1996)
gdp.data <- rbind(gdp.data,
                  gdp.download(component = "GDP_SAN", years = 1997:2015))
```





























